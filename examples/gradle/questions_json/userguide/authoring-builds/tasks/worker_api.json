[
    {
        "question": "What is the primary benefit of using parallel task execution in Gradle?",
        "options": {
            "A": "It allows tasks to run sequentially for better resource management.",
            "B": "It enables faster completion of builds by utilizing available resources more effectively.",
            "C": "It simplifies the task configuration process.",
            "D": "It reduces the need for custom task classes."
        },
        "correct_answer": "B",
        "explanation": "The primary benefit of using parallel task execution in Gradle is that it enables faster completion of builds by utilizing available resources more effectively. By allowing tasks to run concurrently, Gradle can take advantage of multiple processors, leading to improved build performance."
    },
    {
        "question": "Which API in Gradle is specifically designed to facilitate parallel task execution?",
        "options": {
            "A": "Task API",
            "B": "Worker API",
            "C": "Dependency API",
            "D": "Execution API"
        },
        "correct_answer": "B",
        "explanation": "The Worker API in Gradle is specifically designed to facilitate parallel task execution. It allows the execution of task actions to be broken into discrete units of work that can be processed concurrently and asynchronously, thereby improving build efficiency."
    },
    {
        "question": "What does the isolation mode in the Worker API control?",
        "options": {
            "A": "The order in which tasks are executed.",
            "B": "The level of resource allocation for each task.",
            "C": "How tasks are isolated from each other and the Gradle runtime.",
            "D": "The type of output generated by the tasks."
        },
        "correct_answer": "C",
        "explanation": "The isolation mode in the Worker API controls how tasks are isolated from each other and the rest of the Gradle runtime. It determines the extent to which tasks can affect one another, with options ranging from no isolation to process isolation, which provides the highest level of separation."
    },
    {
        "question": "What is the purpose of using worker daemons in Gradle's parallel task execution?",
        "options": {
            "A": "To ensure all tasks run in a single thread.",
            "B": "To allow for greater levels of isolation and reuse of resources across tasks.",
            "C": "To simplify the configuration of task dependencies.",
            "D": "To eliminate the need for custom task implementations."
        },
        "correct_answer": "B",
        "explanation": "The purpose of using worker daemons in Gradle's parallel task execution is to allow for greater levels of isolation and reuse of resources across tasks. Worker daemons can handle multiple units of work while maintaining their own environment, which helps in managing dependencies and system properties effectively."
    },
    {
        "question": "What is the primary purpose of the Worker API in Gradle?",
        "options": {
            "A": "To execute tasks sequentially without parallel processing",
            "B": "To break up task execution into discrete units of work that can run concurrently",
            "C": "To manage dependencies between tasks in a build",
            "D": "To optimize the memory usage of Gradle builds"
        },
        "correct_answer": "B",
        "explanation": "The primary purpose of the Worker API in Gradle is to break up the execution of a task action into discrete units of work that can be executed concurrently and asynchronously. This allows for better resource utilization and faster build times by enabling parallel processing of independent tasks."
    },
    {
        "question": "Which of the following isolation modes in the Worker API provides the highest level of isolation?",
        "options": {
            "A": "noIsolation()",
            "B": "classLoaderIsolation()",
            "C": "processIsolation()",
            "D": "threadIsolation()"
        },
        "correct_answer": "C",
        "explanation": "The processIsolation() method provides the highest level of isolation in the Worker API. It executes work in a separate process, allowing for complete isolation from other tasks and the Gradle runtime, which is useful for tasks that may have conflicting dependencies or require different runtime environments."
    },
    {
        "question": "What is a key benefit of using the Worker API for task execution?",
        "options": {
            "A": "It simplifies the build script syntax",
            "B": "It allows tasks to run in a single-threaded manner",
            "C": "It enables tasks to utilize multiple processors for faster execution",
            "D": "It eliminates the need for task dependencies"
        },
        "correct_answer": "C",
        "explanation": "A key benefit of using the Worker API is that it enables tasks to utilize multiple processors for faster execution. By breaking tasks into smaller units of work that can run concurrently, the Worker API takes advantage of available system resources, leading to improved build performance."
    },
    {
        "question": "What does the noIsolation() method in the Worker API imply about task execution?",
        "options": {
            "A": "Tasks will run in completely separate processes",
            "B": "Tasks will share the same classloader and project state",
            "C": "Tasks will execute in a single-threaded environment",
            "D": "Tasks will have enhanced security features"
        },
        "correct_answer": "B",
        "explanation": "The noIsolation() method implies that tasks will share the same classloader and project state, which allows for faster execution but at the risk of potential interference between tasks. This mode is the least isolated and is suitable for tasks that do not modify shared state."
    },
    {
        "question": "What is the primary purpose of task isolation in Gradle's Worker API?",
        "options": {
            "A": "To allow tasks to run in parallel without affecting each other",
            "B": "To ensure all tasks share the same classloader",
            "C": "To limit the number of tasks that can run simultaneously",
            "D": "To prevent tasks from accessing external libraries"
        },
        "correct_answer": "A",
        "explanation": "The primary purpose of task isolation in Gradle's Worker API is to allow tasks to run in parallel without affecting each other. This is achieved by using different isolation modes, which control how tasks interact with the Gradle runtime and each other, ensuring that the execution of one task does not interfere with another."
    },
    {
        "question": "Which isolation mode provides the highest level of separation between tasks in Gradle?",
        "options": {
            "A": "noIsolation()",
            "B": "classLoaderIsolation()",
            "C": "processIsolation()",
            "D": "threadIsolation()"
        },
        "correct_answer": "C",
        "explanation": "The processIsolation() mode provides the highest level of separation between tasks in Gradle. It executes tasks in separate processes, allowing for complete isolation of the task's environment, which is particularly useful when tasks may have conflicting dependencies or require different system properties."
    },
    {
        "question": "What is a potential drawback of using the processIsolation() mode?",
        "options": {
            "A": "It is the fastest isolation mode available.",
            "B": "It requires more system resources due to the overhead of starting new processes.",
            "C": "It does not allow for parallel execution of tasks.",
            "D": "It prevents tasks from accessing the Gradle runtime."
        },
        "correct_answer": "B",
        "explanation": "A potential drawback of using the processIsolation() mode is that it requires more system resources due to the overhead of starting new processes for each task. While it provides maximum isolation, the cost of creating and managing these processes can lead to increased execution time, especially for tasks that are run frequently."
    },
    {
        "question": "What does the noIsolation() mode imply for task execution in Gradle?",
        "options": {
            "A": "Tasks will run in completely separate processes.",
            "B": "Tasks will share the same classloader and can affect each other's state.",
            "C": "Tasks will be executed sequentially without any parallelism.",
            "D": "Tasks will have access to different versions of libraries."
        },
        "correct_answer": "B",
        "explanation": "The noIsolation() mode implies that tasks will share the same classloader and can affect each other's state. This mode is the fastest because it has the least overhead, but it also means that tasks can interfere with one another, which can lead to unpredictable behavior if they rely on shared resources."
    },
    {
        "question": "What is the primary purpose of worker daemons in Gradle?",
        "options": {
            "A": "To execute tasks in a single-threaded manner for simplicity",
            "B": "To allow for long-lived processes that can be reused for executing work items",
            "C": "To manage memory consumption by terminating all running tasks",
            "D": "To ensure that all tasks run in isolation without any shared resources"
        },
        "correct_answer": "B",
        "explanation": "The primary purpose of worker daemons in Gradle is to provide long-lived processes that can be reused for executing work items. This allows for efficient resource management and faster execution of tasks, as the overhead of starting a new process for each task is reduced."
    },
    {
        "question": "Which of the following statements about worker daemons is true?",
        "options": {
            "A": "Worker daemons are always terminated after each build session.",
            "B": "Worker daemons can be reused across multiple builds if they meet compatibility criteria.",
            "C": "Worker daemons do not have any memory limitations and can run indefinitely.",
            "D": "Worker daemons are only used for tasks that require high isolation."
        },
        "correct_answer": "B",
        "explanation": "Worker daemons can be reused across multiple builds as long as they meet the compatibility criteria set by Gradle. This allows for improved performance since the overhead of starting a new process is avoided when a compatible daemon is available."
    },
    {
        "question": "What happens to worker daemons when system memory becomes low?",
        "options": {
            "A": "They automatically increase their memory allocation.",
            "B": "They are stopped to free up system resources.",
            "C": "They continue running without any changes.",
            "D": "They switch to a lower isolation mode."
        },
        "correct_answer": "B",
        "explanation": "When system memory becomes low, Gradle will stop worker daemons to minimize memory consumption. This is a mechanism to ensure that the system remains responsive and does not run out of resources."
    },
    {
        "question": "Which of the following is a characteristic of a worker daemon?",
        "options": {
            "A": "It runs in a separate process and can have different settings than the Gradle JVM.",
            "B": "It is designed to run tasks in a single-threaded environment.",
            "C": "It cannot be reused across different builds.",
            "D": "It requires manual termination after each build session."
        },
        "correct_answer": "A",
        "explanation": "A worker daemon runs in a separate process and can have different settings than the Gradle JVM. This allows for greater flexibility and isolation when executing tasks, especially when dealing with external libraries or conflicting system properties."
    },
    {
        "question": "What is the primary benefit of using concurrency in build systems?",
        "options": {
            "A": "To reduce the complexity of build scripts",
            "B": "To fully utilize available system resources and complete builds faster",
            "C": "To ensure that all tasks are executed sequentially",
            "D": "To eliminate the need for task dependencies"
        },
        "correct_answer": "B",
        "explanation": "The primary benefit of using concurrency in build systems is to fully utilize available system resources, allowing multiple tasks to be executed simultaneously. This leads to faster build times as tasks that can run in parallel do not have to wait for others to complete."
    },
    {
        "question": "Which API in Gradle allows for breaking up task execution into discrete units of work that can be executed concurrently?",
        "options": {
            "A": "Task API",
            "B": "Worker API",
            "C": "Dependency API",
            "D": "Execution API"
        },
        "correct_answer": "B",
        "explanation": "The Worker API in Gradle allows for breaking up the execution of a task into discrete units of work that can be executed concurrently and asynchronously. This API is designed to enhance the performance of tasks by enabling parallel execution."
    },
    {
        "question": "What does the isolation mode in the Worker API control?",
        "options": {
            "A": "The order in which tasks are executed",
            "B": "The level of resource allocation for each task",
            "C": "How strongly work items are isolated from each other and the Gradle runtime",
            "D": "The maximum number of tasks that can run simultaneously"
        },
        "correct_answer": "C",
        "explanation": "The isolation mode in the Worker API controls how strongly work items are isolated from each other and the rest of the Gradle runtime. It determines whether tasks share resources or run in completely separate environments, affecting both performance and stability."
    },
    {
        "question": "What is the purpose of using worker daemons in a build system?",
        "options": {
            "A": "To run all tasks in a single process for simplicity",
            "B": "To allow for greater levels of isolation and reuse of resources across tasks",
            "C": "To ensure that tasks are executed in a specific order",
            "D": "To eliminate the need for task dependencies"
        },
        "correct_answer": "B",
        "explanation": "Worker daemons are used in a build system to allow for greater levels of isolation and to enable the reuse of resources across tasks. They can run tasks in separate processes, which helps avoid conflicts and allows for better resource management during builds."
    }
]