[
    {
        "question": "What is a Gradle Task?",
        "options": {
            "A": "A unit of work that can execute a sequence of actions",
            "B": "A configuration file for project settings",
            "C": "A method for compiling Java code",
            "D": "A type of plugin that enhances Gradle functionality"
        },
        "correct_answer": "A",
        "explanation": "A Gradle Task is defined as an executable piece of code that contains sequences of actions. It allows developers to define specific operations that can be executed during the build process, making it a fundamental component of Gradle's build automation."
    },
    {
        "question": "How can actions be added to a Gradle Task?",
        "options": {
            "A": "By using the `doFirst{}` and `doLast{}` closures",
            "B": "By defining them in the build.gradle file only",
            "C": "By creating separate classes for each action",
            "D": "By using the `execute{}` method exclusively"
        },
        "correct_answer": "A",
        "explanation": "Actions can be added to a Gradle Task using the `doFirst{}` and `doLast{}` closures. This allows developers to specify what should happen before and after the main action of the task, providing flexibility in task execution."
    },
    {
        "question": "What is the purpose of the `@TaskAction` annotation in a custom Gradle Task?",
        "options": {
            "A": "To define the input parameters for the task",
            "B": "To indicate the method that contains the task's action logic",
            "C": "To register the task with the Gradle build system",
            "D": "To specify the dependencies of the task"
        },
        "correct_answer": "B",
        "explanation": "The `@TaskAction` annotation is used to indicate the method that contains the logic for the task's action. This tells Gradle which method to execute when the task is run, making it essential for defining custom task behavior."
    },
    {
        "question": "What happens if the input value of a Gradle Task changes since its last execution?",
        "options": {
            "A": "The task will always run regardless of changes",
            "B": "The task will be skipped to save time",
            "C": "Gradle will execute the task again",
            "D": "The task will fail with an error"
        },
        "correct_answer": "C",
        "explanation": "If the input value of a Gradle Task changes since its last execution, Gradle will execute the task again. This behavior is part of Gradle's incremental build feature, which optimizes build times by only running tasks that need to be executed based on changes."
    },
    {
        "question": "What is the primary purpose of a Task in Gradle?",
        "options": {
            "A": "To execute a sequence of actions",
            "B": "To manage project dependencies",
            "C": "To compile source code",
            "D": "To configure project settings"
        },
        "correct_answer": "A",
        "explanation": "The primary purpose of a Task in Gradle is to execute a sequence of actions. Tasks are fundamental units of work in Gradle that can perform various operations, such as compiling code, running tests, or packaging applications."
    },
    {
        "question": "How can actions be added to a Task in Gradle?",
        "options": {
            "A": "Using the `doFirst{}` and `doLast{}` closures",
            "B": "By defining them in the project settings",
            "C": "Through the use of annotations only",
            "D": "By creating separate configuration files"
        },
        "correct_answer": "A",
        "explanation": "Actions can be added to a Task in Gradle using the `doFirst{}` and `doLast{}` closures. The `doFirst{}` closure specifies actions to be executed before the main task action, while the `doLast{}` closure specifies actions to be executed after the main task action."
    },
    {
        "question": "What does the `@Input` annotation signify in a custom Gradle Task?",
        "options": {
            "A": "It indicates that the task has no dependencies",
            "B": "It marks a property that affects the task's execution",
            "C": "It specifies the output of the task",
            "D": "It defines the task's execution order"
        },
        "correct_answer": "B",
        "explanation": "The `@Input` annotation in a custom Gradle Task signifies that the annotated property is an input that affects the task's execution. Gradle uses this information to determine whether the task needs to be executed based on changes to the input values."
    },
    {
        "question": "What is the significance of the `tasks.register()` method in Gradle?",
        "options": {
            "A": "It creates a new task that can be executed later",
            "B": "It configures an existing task",
            "C": "It deletes a task from the build script",
            "D": "It lists all available tasks in the project"
        },
        "correct_answer": "A",
        "explanation": "The `tasks.register()` method in Gradle is used to create a new task that can be executed later. This method allows developers to define tasks dynamically and configure them as needed before they are executed in the build process."
    },
    {
        "question": "What is a key characteristic of a Task in Gradle?",
        "options": {
            "A": "It is a static piece of code that cannot change.",
            "B": "It is an executable piece of code that contains sequences of actions.",
            "C": "It can only run independently without any dependencies.",
            "D": "It is only used during the initialization phase of a build."
        },
        "correct_answer": "B",
        "explanation": "A Task in Gradle is defined as an executable piece of code that contains sequences of actions. This means that it can perform a series of operations when executed, making it a fundamental component of the build process."
    },
    {
        "question": "How can tasks in Gradle be configured to run in a specific order?",
        "options": {
            "A": "By using the `doFirst{}` and `doLast{}` closures.",
            "B": "By defining them as static methods.",
            "C": "By creating them in separate build scripts.",
            "D": "By assigning them unique names only."
        },
        "correct_answer": "A",
        "explanation": "Tasks in Gradle can be configured to run in a specific order by using the `doFirst{}` and `doLast{}` closures. These closures allow you to specify actions that should occur before or after the main action of the task, thus controlling the execution flow."
    },
    {
        "question": "What does the `@Input` annotation signify in a Gradle task?",
        "options": {
            "A": "It indicates that the task has no dependencies.",
            "B": "It marks a property that Gradle should monitor for changes.",
            "C": "It specifies that the task can only run once.",
            "D": "It defines the output of the task."
        },
        "correct_answer": "B",
        "explanation": "The `@Input` annotation in a Gradle task signifies that the annotated property is an input that Gradle should monitor for changes. If the input value changes since the last execution, Gradle will determine that the task needs to run again, ensuring that the build process is up-to-date."
    },
    {
        "question": "What is the purpose of task dependencies in Gradle?",
        "options": {
            "A": "To allow tasks to run in parallel without any order.",
            "B": "To ensure that certain tasks are completed before others start.",
            "C": "To create tasks that do not require any configuration.",
            "D": "To limit the number of tasks that can be executed in a build."
        },
        "correct_answer": "B",
        "explanation": "The purpose of task dependencies in Gradle is to ensure that certain tasks are completed before others start. This allows for a structured build process where tasks can rely on the successful completion of other tasks, facilitating a logical flow in the execution of the build."
    },
    {
        "question": "What is a custom task in Gradle?",
        "options": {
            "A": "A predefined task that cannot be modified",
            "B": "An executable piece of code that contains sequences of actions",
            "C": "A task that only runs during the initialization phase",
            "D": "A task that is automatically generated by Gradle"
        },
        "correct_answer": "B",
        "explanation": "A custom task in Gradle is defined as an executable piece of code that contains sequences of actions. It allows developers to create specific functionalities tailored to their build process, enhancing the flexibility and capability of the build system."
    },
    {
        "question": "Which annotation is used to indicate an input for a custom task in Gradle?",
        "options": {
            "A": "@Output",
            "B": "@TaskAction",
            "C": "@Input",
            "D": "@Action"
        },
        "correct_answer": "C",
        "explanation": "The @Input annotation is used in Gradle to specify an input for a custom task. This helps Gradle determine whether the task needs to be executed based on changes to the input value since the last execution."
    },
    {
        "question": "What is the purpose of the `doFirst{}` and `doLast{}` closures in a Gradle task?",
        "options": {
            "A": "To define the task's dependencies",
            "B": "To specify actions that run before and after the main task action",
            "C": "To register the task with the Gradle build lifecycle",
            "D": "To configure the task's input and output files"
        },
        "correct_answer": "B",
        "explanation": "The `doFirst{}` and `doLast{}` closures in a Gradle task are used to specify actions that should run before and after the main task action, respectively. This allows for additional setup or cleanup operations to be performed around the core functionality of the task."
    },
    {
        "question": "How does Gradle determine if a custom task needs to be executed?",
        "options": {
            "A": "By checking if the task is registered",
            "B": "By evaluating the task's output files",
            "C": "By comparing the input values with previous executions",
            "D": "By the order of tasks defined in the build script"
        },
        "correct_answer": "C",
        "explanation": "Gradle determines if a custom task needs to be executed by comparing the input values with those from previous executions. If the input has changed or if the task has not run before, Gradle will execute the task to ensure the build reflects the latest changes."
    },
    {
        "question": "What is the primary purpose of a Task Action in Gradle?",
        "options": {
            "A": "To define the sequence of actions that a task will execute",
            "B": "To initialize the Gradle build lifecycle",
            "C": "To register new tasks in the build script",
            "D": "To configure project settings"
        },
        "correct_answer": "A",
        "explanation": "The primary purpose of a Task Action in Gradle is to define the sequence of actions that a task will execute. It encapsulates the logic that will be performed when the task is run, allowing developers to specify what should happen during the execution phase of the task."
    },
    {
        "question": "Which annotation is used to indicate a method as a Task Action in Gradle?",
        "options": {
            "A": "@TaskMethod",
            "B": "@TaskAction",
            "C": "@ActionMethod",
            "D": "@ExecuteTask"
        },
        "correct_answer": "B",
        "explanation": "The @TaskAction annotation is used to indicate that a method is a Task Action in Gradle. This annotation tells Gradle that the method should be executed when the task is run, allowing the developer to define the specific actions that the task will perform."
    },
    {
        "question": "What happens if the input value of a task changes since its last execution?",
        "options": {
            "A": "The task will always run regardless of changes.",
            "B": "Gradle will skip the task to save time.",
            "C": "Gradle will execute the task again.",
            "D": "The task will be marked as up-to-date."
        },
        "correct_answer": "C",
        "explanation": "If the input value of a task changes since its last execution, Gradle will execute the task again. This behavior ensures that tasks are run when necessary, based on changes to their inputs, which helps maintain the integrity of the build process."
    },
    {
        "question": "What is the role of the `doFirst{}` and `doLast{}` closures in a Gradle task?",
        "options": {
            "A": "To define the task's dependencies",
            "B": "To specify actions that occur before and after the main task action",
            "C": "To register new tasks in the build script",
            "D": "To configure project settings"
        },
        "correct_answer": "B",
        "explanation": "The `doFirst{}` and `doLast{}` closures in a Gradle task are used to specify actions that occur before and after the main task action, respectively. This allows developers to add additional behavior to the task execution process, enhancing its functionality."
    },
    {
        "question": "What is the purpose of the @Input annotation in a Gradle task?",
        "options": {
            "A": "To specify the output files of the task",
            "B": "To indicate that a property is an input for the task",
            "C": "To define the execution order of tasks",
            "D": "To mark a task as optional"
        },
        "correct_answer": "B",
        "explanation": "The @Input annotation is used to indicate that a property is an input for the task. This helps Gradle determine whether the task needs to be executed based on changes to the input values since the last execution. If the input value has changed, Gradle will run the task again."
    },
    {
        "question": "How does Gradle determine if a task needs to be executed based on input annotations?",
        "options": {
            "A": "By checking if the task has been manually triggered",
            "B": "By comparing the current input values to previous values",
            "C": "By analyzing the task's execution time",
            "D": "By evaluating the number of dependencies the task has"
        },
        "correct_answer": "B",
        "explanation": "Gradle determines if a task needs to be executed by comparing the current input values to the values from the last execution. If any input value has changed, Gradle will execute the task to ensure that the output reflects the latest inputs."
    },
    {
        "question": "What is the role of the @TaskAction annotation in a Gradle task?",
        "options": {
            "A": "To define the task's dependencies",
            "B": "To specify the input files for the task",
            "C": "To mark the method that contains the task's action logic",
            "D": "To indicate the task's execution phase"
        },
        "correct_answer": "C",
        "explanation": "The @TaskAction annotation is used to mark the method that contains the logic to be executed when the task runs. This method is where the main actions of the task are defined, and it is called during the execution phase of the task lifecycle."
    },
    {
        "question": "What happens if a task's input value has not changed since the last execution?",
        "options": {
            "A": "The task will always execute regardless of input changes",
            "B": "The task will be skipped and not executed",
            "C": "The task will execute but with a warning",
            "D": "The task will execute in a different order"
        },
        "correct_answer": "B",
        "explanation": "If a task's input value has not changed since the last execution, Gradle will skip the task and not execute it. This optimization helps improve build performance by avoiding unnecessary work when the inputs have not changed."
    }
]