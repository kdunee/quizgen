[
    {
        "question": "What is the primary purpose of dependency resolution in Gradle?",
        "options": {
            "A": "To compile source code into executable files",
            "B": "To manage and resolve conflicts between library dependencies",
            "C": "To optimize the performance of the application",
            "D": "To automate the testing process"
        },
        "correct_answer": "B",
        "explanation": "The primary purpose of dependency resolution in Gradle is to manage and resolve conflicts between library dependencies. This involves determining which versions of libraries to use when multiple versions are requested, ensuring that the project can compile and run correctly without conflicts."
    },
    {
        "question": "What type of conflict occurs when two dependencies require different versions of the same module?",
        "options": {
            "A": "Capability conflict",
            "B": "Version conflict",
            "C": "Dependency conflict",
            "D": "Module conflict"
        },
        "correct_answer": "B",
        "explanation": "A version conflict occurs when two or more dependencies require different versions of the same module. Gradle resolves this by selecting the highest version requested in the dependency graph, ensuring that the most up-to-date version is used."
    },
    {
        "question": "How does Gradle typically resolve capability conflicts?",
        "options": {
            "A": "By ignoring the conflict and proceeding with the build",
            "B": "By selecting the lowest version of the conflicting capabilities",
            "C": "By failing the build and reporting the conflict",
            "D": "By automatically merging the conflicting capabilities"
        },
        "correct_answer": "C",
        "explanation": "Gradle typically resolves capability conflicts by failing the build and reporting the conflict. This approach ensures that developers are made aware of the issue so they can manually resolve it, often by specifying which capability to use in the resolution strategy."
    },
    {
        "question": "What is the role of the `constraints` block in Gradle's dependency management?",
        "options": {
            "A": "To define the order of dependency resolution",
            "B": "To specify a specific version of a dependency to be used",
            "C": "To automatically update all dependencies to their latest versions",
            "D": "To remove unused dependencies from the project"
        },
        "correct_answer": "B",
        "explanation": "The `constraints` block in Gradle's dependency management is used to specify a specific version of a dependency to be used. This helps Gradle make informed decisions during dependency resolution, ensuring that the correct versions are selected based on the project's requirements."
    },
    {
        "question": "What is a version conflict in dependency resolution?",
        "options": {
            "A": "When two dependencies require the same module but with different versions",
            "B": "When a dependency is missing from the project",
            "C": "When a dependency is declared multiple times in the same version",
            "D": "When a dependency is incompatible with the programming language used"
        },
        "correct_answer": "A",
        "explanation": "A version conflict occurs when two or more dependencies require the same module but specify different versions. This situation can lead to ambiguity in which version should be used, prompting the dependency resolution system to determine the best course of action, typically by selecting the highest version."
    },
    {
        "question": "How does Gradle typically resolve version conflicts?",
        "options": {
            "A": "By ignoring all version specifications",
            "B": "By selecting the lowest version available",
            "C": "By selecting the highest version requested",
            "D": "By prompting the user for a decision"
        },
        "correct_answer": "C",
        "explanation": "Gradle resolves version conflicts by considering all requested versions in the dependency graph and, by default, selecting the highest version. This approach helps ensure that the most up-to-date and compatible version of a library is used in the project."
    },
    {
        "question": "What happens when Gradle encounters a capability conflict?",
        "options": {
            "A": "It automatically resolves the conflict by selecting a version",
            "B": "It fails the build and reports the conflict",
            "C": "It ignores the conflict and continues the build",
            "D": "It prompts the user to manually resolve the conflict"
        },
        "correct_answer": "B",
        "explanation": "When Gradle encounters a capability conflict, it generally fails the build and reports the conflict. This occurs when multiple variants of a component declare the same capability, leading to ambiguity about which variant should be used."
    },
    {
        "question": "What is a capability conflict in the context of dependency resolution?",
        "options": {
            "A": "When two dependencies require the same module but with different versions",
            "B": "When multiple artifacts in the dependency graph provide the same functionality",
            "C": "When a dependency is missing from the project",
            "D": "When a dependency is declared but not used in the project"
        },
        "correct_answer": "B",
        "explanation": "A capability conflict occurs when multiple variants of a component in the dependency graph declare the same capability. This situation can lead to ambiguity about which variant to use, and Gradle typically fails the build and reports the conflict to ensure clarity in dependency resolution."
    },
    {
        "question": "How does Gradle typically handle capability conflicts during dependency resolution?",
        "options": {
            "A": "It automatically selects the lowest version of the conflicting dependencies",
            "B": "It ignores the conflict and continues the build process",
            "C": "It fails the build and reports the conflict",
            "D": "It merges the conflicting dependencies into a single version"
        },
        "correct_answer": "C",
        "explanation": "Gradle generally fails the build and reports a capability conflict when it encounters multiple variants of a component that declare the same capability. This approach ensures that developers are aware of the conflict and can take appropriate action to resolve it."
    },
    {
        "question": "What is one way to resolve capability conflicts in Gradle?",
        "options": {
            "A": "By removing all dependencies from the project",
            "B": "By specifying which capability to use in the resolutionStrategy block",
            "C": "By downgrading all dependencies to their lowest versions",
            "D": "By ignoring the conflict and allowing Gradle to choose automatically"
        },
        "correct_answer": "B",
        "explanation": "One way to resolve capability conflicts in Gradle is by specifying which capability to use in the `resolutionStrategy` block. This allows developers to control which version of a capability is selected, thereby resolving the conflict explicitly."
    },
    {
        "question": "What is the primary purpose of dependency constraints in Gradle?",
        "options": {
            "A": "To enforce specific versions of dependencies",
            "B": "To automatically update all dependencies to the latest version",
            "C": "To remove unused dependencies from the project",
            "D": "To create a backup of the project dependencies"
        },
        "correct_answer": "A",
        "explanation": "The primary purpose of dependency constraints in Gradle is to enforce specific versions of dependencies. This helps ensure that the project uses compatible versions of libraries, preventing potential conflicts and issues during dependency resolution."
    },
    {
        "question": "What happens when a version conflict occurs in Gradle?",
        "options": {
            "A": "Gradle will ignore the conflict and proceed with the build",
            "B": "Gradle will select the highest version of the conflicting dependencies",
            "C": "Gradle will automatically downgrade all dependencies to the lowest version",
            "D": "Gradle will stop the build and report the conflict"
        },
        "correct_answer": "B",
        "explanation": "When a version conflict occurs in Gradle, it will select the highest version of the conflicting dependencies by default. This approach helps to ensure that the most recent and potentially most compatible version is used in the project."
    },
    {
        "question": "What is a capability conflict in the context of Gradle dependency resolution?",
        "options": {
            "A": "When two dependencies require the same version of a library",
            "B": "When multiple artifacts provide the same functionality",
            "C": "When a dependency is missing from the project",
            "D": "When a dependency is declared but not used in the project"
        },
        "correct_answer": "B",
        "explanation": "A capability conflict occurs in Gradle when multiple artifacts in the dependency graph declare the same capability. This situation can lead to ambiguity about which artifact should be used, and Gradle will typically fail the build and report the conflict."
    },
    {
        "question": "How can developers manually resolve capability conflicts in Gradle?",
        "options": {
            "A": "By removing all conflicting dependencies from the project",
            "B": "By specifying which capability to use in the resolutionStrategy block",
            "C": "By updating all dependencies to their latest versions",
            "D": "By ignoring the conflict and allowing Gradle to choose automatically"
        },
        "correct_answer": "B",
        "explanation": "Developers can manually resolve capability conflicts in Gradle by specifying which capability to use in the resolutionStrategy block. This allows for greater control over which version of a capability is selected, helping to avoid build failures due to conflicts."
    },
    {
        "question": "What is the primary purpose of a resolution strategy in dependency management?",
        "options": {
            "A": "To define how to handle conflicts between different versions of dependencies",
            "B": "To automatically update all dependencies to their latest versions",
            "C": "To remove unused dependencies from the project",
            "D": "To create a backup of the project dependencies"
        },
        "correct_answer": "A",
        "explanation": "The primary purpose of a resolution strategy in dependency management is to define how to handle conflicts that arise when different versions of dependencies are required. This includes determining which version to select when multiple versions are present in the dependency graph, ensuring that the project can build successfully without version-related issues."
    },
    {
        "question": "What type of conflict occurs when two dependencies require the same module but with different versions?",
        "options": {
            "A": "Capability conflict",
            "B": "Version conflict",
            "C": "Dependency conflict",
            "D": "Module conflict"
        },
        "correct_answer": "B",
        "explanation": "A version conflict occurs when two or more dependencies require the same module but specify different versions. This situation necessitates a resolution strategy to determine which version should be used in the project, typically by selecting the highest version by default."
    },
    {
        "question": "How does Gradle typically resolve version conflicts by default?",
        "options": {
            "A": "By selecting the lowest version available",
            "B": "By ignoring all version specifications",
            "C": "By selecting the highest version available",
            "D": "By prompting the user for a decision"
        },
        "correct_answer": "C",
        "explanation": "By default, Gradle resolves version conflicts by selecting the highest version available among the conflicting dependencies. This approach helps ensure that the project uses the most up-to-date and potentially compatible version of a library."
    },
    {
        "question": "What happens when Gradle encounters a capability conflict during dependency resolution?",
        "options": {
            "A": "It automatically resolves the conflict by selecting a version",
            "B": "It fails the build and reports the conflict",
            "C": "It ignores the conflict and continues the build",
            "D": "It prompts the user to manually resolve the conflict"
        },
        "correct_answer": "B",
        "explanation": "When Gradle encounters a capability conflict, it generally fails the build and reports the conflict. This is because multiple variants of a component declaring the same capability can lead to ambiguity, and Gradle requires explicit resolution to proceed."
    }
]