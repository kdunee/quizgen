[
    {
        "question": "What is the primary purpose of a type in programming?",
        "options": {
            "A": "To define a set of values along with specific operations and methods for those values",
            "B": "To store data in a fixed format without any operations",
            "C": "To create a unique identifier for variables",
            "D": "To enforce security measures in code execution"
        },
        "correct_answer": "A",
        "explanation": "The primary purpose of a type in programming is to define a set of values along with specific operations and methods that can be performed on those values. This allows for better organization and manipulation of data within a program."
    },
    {
        "question": "Which of the following correctly describes a 'named type'?",
        "options": {
            "A": "A type that is defined without any specific name",
            "B": "A type that is created using type literals only",
            "C": "A type that has a name and can be predeclared or defined through declarations",
            "D": "A type that can only be used in a single instance"
        },
        "correct_answer": "C",
        "explanation": "A 'named type' is a type that has a specific name and can be either predeclared or introduced through type declarations. This allows for the type to be referenced and used throughout the code."
    },
    {
        "question": "What is a characteristic of composite types?",
        "options": {
            "A": "They can only be defined using primitive types.",
            "B": "They are constructed from existing types and can include multiple elements.",
            "C": "They cannot contain other types as components.",
            "D": "They are always mutable and can be changed after creation."
        },
        "correct_answer": "B",
        "explanation": "Composite types are characterized by being constructed from existing types and can include multiple elements. This allows for the creation of complex data structures that can hold various types of data."
    },
    {
        "question": "What is the significance of type literals in defining types?",
        "options": {
            "A": "They are used to create unique identifiers for variables.",
            "B": "They allow for the construction of types from existing types.",
            "C": "They are only applicable to primitive data types.",
            "D": "They restrict the operations that can be performed on a type."
        },
        "correct_answer": "B",
        "explanation": "Type literals are significant because they allow for the construction of new types from existing types. This enables programmers to create more complex and structured data types that can better represent the data being handled."
    },
    {
        "question": "What is a type name in programming?",
        "options": {
            "A": "A label that identifies a specific type and its associated operations.",
            "B": "A unique identifier for a variable in a program.",
            "C": "A method that defines how to manipulate data.",
            "D": "A function that returns the type of a variable."
        },
        "correct_answer": "A",
        "explanation": "A type name is a label that identifies a specific type and its associated operations. It allows programmers to refer to a particular type in a clear and consistent manner, facilitating the use of that type in various contexts within the code."
    },
    {
        "question": "When is a type name followed by type arguments?",
        "options": {
            "A": "When the type is a defined type.",
            "B": "When the type is generic.",
            "C": "When the type is a primitive type.",
            "D": "When the type is an alias."
        },
        "correct_answer": "B",
        "explanation": "A type name is followed by type arguments when the type is generic. This allows the type to be parameterized, enabling the creation of more flexible and reusable code structures that can operate on different data types."
    },
    {
        "question": "What distinguishes a named type from an unnamed type?",
        "options": {
            "A": "Named types have a specific identifier, while unnamed types do not.",
            "B": "Unnamed types can only be used in function parameters.",
            "C": "Named types cannot be used in type declarations.",
            "D": "Unnamed types are always primitive types."
        },
        "correct_answer": "A",
        "explanation": "Named types are distinguished by having a specific identifier that allows them to be referenced throughout the code, while unnamed types do not have such identifiers and are typically defined inline or through type literals."
    },
    {
        "question": "What is the purpose of a type literal?",
        "options": {
            "A": "To create a new type from existing types.",
            "B": "To define a variable's initial value.",
            "C": "To specify the operations available for a type.",
            "D": "To declare a function's return type."
        },
        "correct_answer": "A",
        "explanation": "A type literal is used to create a new type from existing types. It allows programmers to define composite types by combining other types, facilitating the construction of more complex data structures."
    },
    {
        "question": "What is a type literal in programming?",
        "options": {
            "A": "A way to define a type using existing types",
            "B": "A method for creating a new variable",
            "C": "A function that returns a type",
            "D": "A syntax for declaring constants"
        },
        "correct_answer": "A",
        "explanation": "A type literal is a way to define a type by composing it from existing types. This allows for the creation of new types based on the structure and characteristics of already defined types, such as arrays, structs, or slices."
    },
    {
        "question": "Which of the following is NOT a type that can be constructed using a type literal?",
        "options": {
            "A": "ArrayType",
            "B": "StructType",
            "C": "FunctionType",
            "D": "VariableType"
        },
        "correct_answer": "D",
        "explanation": "VariableType is not a recognized type that can be constructed using a type literal. Type literals are specifically used to create composite types such as arrays, structs, pointers, functions, interfaces, slices, maps, and channels."
    },
    {
        "question": "What is the significance of a type literal's length in an array type?",
        "options": {
            "A": "It determines the maximum number of elements the array can hold.",
            "B": "It is irrelevant and can be any value.",
            "C": "It must evaluate to a negative constant.",
            "D": "It is only used for documentation purposes."
        },
        "correct_answer": "A",
        "explanation": "The length of an array type, specified in a type literal, is significant because it determines the number of elements the array can hold. This length must evaluate to a non-negative constant, ensuring that the array has a defined size."
    },
    {
        "question": "How does a type literal differ from a type name?",
        "options": {
            "A": "A type literal is always a predefined type.",
            "B": "A type name refers to a specific type, while a type literal constructs a type from existing types.",
            "C": "A type literal cannot be used in type declarations.",
            "D": "A type name can only be used for primitive types."
        },
        "correct_answer": "B",
        "explanation": "A type name refers to a specific, often predefined type, while a type literal is a construct that allows the creation of a new type by combining existing types. This distinction is important for understanding how types are defined and utilized in programming."
    },
    {
        "question": "What does a boolean type represent in programming?",
        "options": {
            "A": "A set of numeric values",
            "B": "A set of Boolean truth values",
            "C": "A set of string values",
            "D": "A set of complex data structures"
        },
        "correct_answer": "B",
        "explanation": "A boolean type represents the set of Boolean truth values, which are typically denoted by the constants 'true' and 'false'. This type is fundamental in programming for making decisions and controlling the flow of execution based on conditions."
    },
    {
        "question": "Which of the following is the predeclared boolean type in many programming languages?",
        "options": {
            "A": "boolean",
            "B": "bool",
            "C": "truefalse",
            "D": "bit"
        },
        "correct_answer": "B",
        "explanation": "The predeclared boolean type in many programming languages is 'bool'. This type is used to represent truth values and is essential for logical operations and control structures."
    },
    {
        "question": "What are the possible values of a boolean type?",
        "options": {
            "A": "Any integer value",
            "B": "Any string value",
            "C": "Only true and false",
            "D": "Any floating-point value"
        },
        "correct_answer": "C",
        "explanation": "The possible values of a boolean type are strictly limited to 'true' and 'false'. These values are used to represent the two states of truth in logical expressions and conditions."
    },
    {
        "question": "In programming, how is a boolean type typically used?",
        "options": {
            "A": "To store collections of data",
            "B": "To represent numeric calculations",
            "C": "To control the flow of execution based on conditions",
            "D": "To define complex data structures"
        },
        "correct_answer": "C",
        "explanation": "A boolean type is typically used to control the flow of execution based on conditions. It allows for decision-making in code, enabling branching and looping based on whether a condition evaluates to true or false."
    },
    {
        "question": "What are numeric types primarily used to represent?",
        "options": {
            "A": "Boolean values",
            "B": "Character data",
            "C": "Integer, floating-point, and complex values",
            "D": "String sequences"
        },
        "correct_answer": "C",
        "explanation": "Numeric types are used to represent integer, floating-point, and complex values. They are essential for performing mathematical operations and calculations in programming."
    },
    {
        "question": "Which of the following is a characteristic of the predeclared numeric types?",
        "options": {
            "A": "They are all defined types and distinct from each other.",
            "B": "They can be mixed without explicit conversions.",
            "C": "They are only available in specific programming languages.",
            "D": "They are all signed types."
        },
        "correct_answer": "A",
        "explanation": "Predeclared numeric types are defined types and are distinct from each other, meaning that even if they have the same size, they are treated as different types in expressions and assignments."
    },
    {
        "question": "What is required when mixing different numeric types in an expression?",
        "options": {
            "A": "Implicit conversion",
            "B": "No special handling is needed",
            "C": "Explicit conversion",
            "D": "Type casting is not allowed"
        },
        "correct_answer": "C",
        "explanation": "When mixing different numeric types in an expression, explicit conversions are required to ensure that the types are compatible. This prevents errors and maintains type safety in the code."
    },
    {
        "question": "Which of the following is NOT a predeclared numeric type?",
        "options": {
            "A": "int32",
            "B": "float64",
            "C": "string",
            "D": "uint8"
        },
        "correct_answer": "C",
        "explanation": "The type 'string' is not a numeric type; it represents a sequence of characters. In contrast, int32, float64, and uint8 are all predeclared numeric types used for representing numerical values."
    },
    {
        "question": "What is a defining characteristic of string types in programming?",
        "options": {
            "A": "Strings are mutable and can be changed after creation.",
            "B": "Strings are a sequence of bytes and are immutable.",
            "C": "Strings can only contain numeric values.",
            "D": "Strings are always fixed in length and cannot be empty."
        },
        "correct_answer": "B",
        "explanation": "String types represent a sequence of bytes and are immutable, meaning once a string is created, its contents cannot be changed. This immutability is a key characteristic that differentiates strings from other data types that can be modified."
    },
    {
        "question": "How can the length of a string be determined in programming?",
        "options": {
            "A": "By using the built-in function len()",
            "B": "By counting the number of characters manually",
            "C": "By accessing the string's memory address",
            "D": "By using the string's type declaration"
        },
        "correct_answer": "A",
        "explanation": "The length of a string can be determined using the built-in function len(). This function returns the number of bytes in the string, which is a straightforward way to access this information programmatically."
    },
    {
        "question": "What happens if you try to change the contents of a string after it has been created?",
        "options": {
            "A": "The string is updated successfully.",
            "B": "An error occurs because strings are immutable.",
            "C": "The string is duplicated with the new content.",
            "D": "The program crashes due to memory issues."
        },
        "correct_answer": "B",
        "explanation": "If you try to change the contents of a string after it has been created, an error occurs because strings are immutable. This means that any operation that appears to modify a string actually creates a new string instead."
    },
    {
        "question": "What is the predeclared string type in programming languages that support string types?",
        "options": {
            "A": "text",
            "B": "string",
            "C": "char",
            "D": "byte"
        },
        "correct_answer": "B",
        "explanation": "The predeclared string type in many programming languages is denoted as 'string'. This type is used to represent sequences of characters or bytes, and it is a defined type within the language."
    },
    {
        "question": "What defines the length of an array type?",
        "options": {
            "A": "The number of elements in the array, which must be a non-negative constant.",
            "B": "The maximum number of elements that can be stored in the array, which can be any integer.",
            "C": "The total size of the array in bytes, which can vary based on the element type.",
            "D": "The number of dimensions the array has, which can be any positive integer."
        },
        "correct_answer": "A",
        "explanation": "The length of an array type is defined as the number of elements it contains, and this length must be a non-negative constant. This is a fundamental characteristic of array types, distinguishing them from other types that may have variable lengths."
    },
    {
        "question": "Which of the following statements is true about array types?",
        "options": {
            "A": "Array types can have elements of any type, including other arrays.",
            "B": "The length of an array is part of its type and must be a constant.",
            "C": "Arrays can be multi-dimensional but must be declared with a fixed number of dimensions.",
            "D": "Array types can contain elements of different types as long as they are all numeric."
        },
        "correct_answer": "B",
        "explanation": "The length of an array is indeed part of its type and must be a constant. This means that once an array type is defined, its length cannot change, and it must be specified at the time of declaration."
    },
    {
        "question": "What is a key restriction on the element types of an array?",
        "options": {
            "A": "An array cannot have an element of a type that is itself an array.",
            "B": "An array can only contain elements of primitive types.",
            "C": "An array must contain at least one element of a defined type.",
            "D": "An array can only contain elements of the same type as its length."
        },
        "correct_answer": "A",
        "explanation": "A key restriction on array types is that they cannot have an element of a type that is itself an array. This prevents the creation of infinitely nested arrays, ensuring that the structure remains manageable and well-defined."
    },
    {
        "question": "How can the length of an array be determined in a program?",
        "options": {
            "A": "By using the built-in function len() which returns the length of the array.",
            "B": "By accessing a special property of the array type that stores its length.",
            "C": "By calculating the total size of the array in bytes and dividing by the size of the element type.",
            "D": "By using a predefined constant that represents the maximum length of arrays."
        },
        "correct_answer": "A",
        "explanation": "The length of an array can be determined using the built-in function len(), which returns the number of elements in the array. This function provides a straightforward way to access the length of any array in a program."
    },
    {
        "question": "What is a slice in programming?",
        "options": {
            "A": "A fixed-size array of elements of the same type",
            "B": "A descriptor for a contiguous segment of an underlying array",
            "C": "A type that can only hold a single value",
            "D": "A collection of elements that can only be accessed sequentially"
        },
        "correct_answer": "B",
        "explanation": "A slice is a descriptor for a contiguous segment of an underlying array, allowing access to a numbered sequence of elements from that array. Unlike arrays, slices can change in length during execution, making them more flexible for dynamic data handling."
    },
    {
        "question": "How can the length of a slice be determined?",
        "options": {
            "A": "Using the built-in function len()",
            "B": "By accessing the first element of the slice",
            "C": "By counting the number of elements manually",
            "D": "Using the built-in function cap()"
        },
        "correct_answer": "A",
        "explanation": "The length of a slice can be determined using the built-in function len(). This function returns the number of elements in the slice, which may change during execution as elements are added or removed."
    },
    {
        "question": "What happens to the underlying array when a slice is created?",
        "options": {
            "A": "The underlying array is copied to create the slice",
            "B": "The slice is independent of the underlying array",
            "C": "The slice shares storage with its underlying array",
            "D": "The underlying array is deleted"
        },
        "correct_answer": "C",
        "explanation": "When a slice is created, it shares storage with its underlying array. This means that changes made to the elements of the slice will affect the underlying array and vice versa, as they reference the same memory."
    },
    {
        "question": "What is the capacity of a slice?",
        "options": {
            "A": "The maximum number of elements it can hold without resizing",
            "B": "The total number of elements currently in the slice",
            "C": "The number of elements that can be added to the slice before it becomes full",
            "D": "The size of the underlying array in bytes"
        },
        "correct_answer": "A",
        "explanation": "The capacity of a slice refers to the maximum number of elements it can hold without needing to resize. It is the sum of the length of the slice and the length of the underlying array beyond the slice, allowing for efficient memory management."
    },
    {
        "question": "What is a struct type in programming?",
        "options": {
            "A": "A sequence of named elements, each with a name and a type.",
            "B": "A collection of functions that operate on data.",
            "C": "A type that can only contain primitive data types.",
            "D": "A type that represents a single value."
        },
        "correct_answer": "A",
        "explanation": "A struct type is defined as a sequence of named elements, known as fields, where each field has a specific name and type. This allows for the grouping of related data under a single type, making it easier to manage and manipulate complex data structures."
    },
    {
        "question": "Which of the following statements about struct types is true?",
        "options": {
            "A": "Field names within a struct must be unique.",
            "B": "Structs can contain fields of any type, including other structs.",
            "C": "Structs cannot have methods associated with them.",
            "D": "All fields in a struct must be of the same type."
        },
        "correct_answer": "A",
        "explanation": "Field names within a struct must be unique to avoid conflicts and ensure that each field can be accessed distinctly. This uniqueness is essential for the proper functioning of the struct and its methods."
    },
    {
        "question": "What is an embedded field in a struct?",
        "options": {
            "A": "A field that is declared without a name and acts as a field of its type.",
            "B": "A field that can only contain primitive data types.",
            "C": "A field that is declared with a unique identifier.",
            "D": "A field that can only be accessed through a pointer."
        },
        "correct_answer": "A",
        "explanation": "An embedded field in a struct is a field that is declared without an explicit field name. Instead, the type name itself serves as the field name, allowing for a more concise struct definition and enabling the promotion of methods and fields from the embedded type."
    },
    {
        "question": "What happens if a struct type contains a field of its own type?",
        "options": {
            "A": "It is allowed and creates a recursive structure.",
            "B": "It results in a compilation error.",
            "C": "It automatically initializes the field.",
            "D": "It creates a new type that is a subtype of the original struct."
        },
        "correct_answer": "B",
        "explanation": "A struct type cannot contain a field of its own type, as this would create an infinite recursive structure. This restriction is in place to maintain the integrity and usability of struct types in programming."
    },
    {
        "question": "What does a pointer type denote in programming?",
        "options": {
            "A": "A reference to a variable of a specified base type",
            "B": "A collection of variables of different types",
            "C": "A function that returns a variable",
            "D": "A type that cannot be initialized"
        },
        "correct_answer": "A",
        "explanation": "A pointer type denotes the set of all pointers to variables of a given base type. It allows for the manipulation of memory addresses directly, enabling efficient data handling and management."
    },
    {
        "question": "What is the value of an uninitialized pointer?",
        "options": {
            "A": "0",
            "B": "nil",
            "C": "undefined",
            "D": "empty"
        },
        "correct_answer": "B",
        "explanation": "The value of an uninitialized pointer is 'nil'. This indicates that the pointer does not currently reference any valid memory address, which is important for preventing dereferencing errors."
    },
    {
        "question": "Which of the following is a valid declaration of a pointer type?",
        "options": {
            "A": "int*",
            "B": "*int",
            "C": "pointer int",
            "D": "int&"
        },
        "correct_answer": "B",
        "explanation": "The correct syntax for declaring a pointer type in this context is '*int', which indicates a pointer to an integer type. This follows the standard notation for pointer types in many programming languages."
    },
    {
        "question": "What is the primary purpose of using pointer types?",
        "options": {
            "A": "To create new data types",
            "B": "To allow functions to modify the original variable",
            "C": "To store multiple values of different types",
            "D": "To define constant values"
        },
        "correct_answer": "B",
        "explanation": "The primary purpose of using pointer types is to allow functions to modify the original variable. By passing a pointer to a variable, the function can directly access and change the value stored at that memory address."
    },
    {
        "question": "What does a function type denote in programming?",
        "options": {
            "A": "The set of all functions with the same parameter and result types",
            "B": "A specific function that can be called multiple times",
            "C": "A type that can only return a single value",
            "D": "A type that does not accept any parameters"
        },
        "correct_answer": "A",
        "explanation": "A function type denotes the set of all functions that share the same parameter and result types. This allows for the definition of variables that can hold references to any function matching that signature, enabling flexibility in function usage."
    },
    {
        "question": "Which of the following is true about the parameters in a function type?",
        "options": {
            "A": "All parameters must have unique names within the function type.",
            "B": "Parameters can be omitted if they are not needed.",
            "C": "The names of parameters are optional and can be blank.",
            "D": "Parameters must always be of the same type."
        },
        "correct_answer": "C",
        "explanation": "In a function type, the names of parameters are optional. If present, they must be unique, but if absent, each type stands for one item of that type. This allows for flexibility in defining function signatures."
    },
    {
        "question": "What is a variadic function type?",
        "options": {
            "A": "A function type that can only accept one parameter",
            "B": "A function type that can accept zero or more arguments for the last parameter",
            "C": "A function type that does not return any values",
            "D": "A function type that can only be called once"
        },
        "correct_answer": "B",
        "explanation": "A variadic function type is defined as one that can accept zero or more arguments for the last parameter. This allows for greater flexibility in how functions can be called, accommodating varying numbers of arguments."
    },
    {
        "question": "What happens if a function type has multiple unnamed results?",
        "options": {
            "A": "The function must be defined with unique names for each result.",
            "B": "The results can be returned without parentheses.",
            "C": "The function type is invalid and cannot be used.",
            "D": "The results must be enclosed in parentheses."
        },
        "correct_answer": "D",
        "explanation": "If a function type has multiple unnamed results, the results must be enclosed in parentheses. This is a requirement for clarity in function signatures, ensuring that the return types are clearly defined."
    },
    {
        "question": "What is the primary purpose of an interface type in programming?",
        "options": {
            "A": "To define a set of methods that implementing types must provide",
            "B": "To create a new data type that cannot be modified",
            "C": "To store a collection of values of different types",
            "D": "To represent a single value of a specific type"
        },
        "correct_answer": "A",
        "explanation": "The primary purpose of an interface type is to define a set of methods that any implementing type must provide. This allows for polymorphism, where different types can be treated uniformly based on the methods they implement, enabling flexible and reusable code."
    },
    {
        "question": "Which of the following statements about interface types is true?",
        "options": {
            "A": "An interface type can only contain method declarations.",
            "B": "An interface type can contain both method and type elements.",
            "C": "An interface type cannot be implemented by any type.",
            "D": "An interface type can only be used with primitive data types."
        },
        "correct_answer": "B",
        "explanation": "An interface type can contain both method declarations and type elements. This allows for a more flexible definition of what types can implement the interface, as it can specify methods that must be implemented as well as types that are acceptable."
    },
    {
        "question": "What does it mean for a type to implement an interface?",
        "options": {
            "A": "The type must inherit from the interface.",
            "B": "The type must provide all methods declared in the interface.",
            "C": "The type must be a subclass of the interface type.",
            "D": "The type must be defined within the interface."
        },
        "correct_answer": "B",
        "explanation": "For a type to implement an interface, it must provide all methods declared in that interface. This means that the type must have the same method signatures as those specified in the interface, allowing it to be used wherever the interface type is expected."
    },
    {
        "question": "What is a basic interface?",
        "options": {
            "A": "An interface that contains no methods.",
            "B": "An interface that can only be implemented by one type.",
            "C": "An interface that specifies a list of methods that define its type set.",
            "D": "An interface that cannot be embedded in other interfaces."
        },
        "correct_answer": "C",
        "explanation": "A basic interface is one that specifies a list of methods that define its type set. This means that any type that implements all of the methods in the basic interface is considered to be part of the interface's type set."
    },
    {
        "question": "What is a map type in programming?",
        "options": {
            "A": "An ordered collection of elements indexed by unique keys",
            "B": "An unordered group of elements indexed by unique keys",
            "C": "A sequence of elements of the same type",
            "D": "A collection of elements that can be accessed by their index"
        },
        "correct_answer": "B",
        "explanation": "A map type is defined as an unordered group of elements of one type, called the element type, indexed by a set of unique keys of another type, called the key type. This allows for efficient retrieval of values based on their associated keys."
    },
    {
        "question": "What must be true about the key type in a map?",
        "options": {
            "A": "It must be a function type.",
            "B": "It must support comparison operators.",
            "C": "It can be any type, including slices.",
            "D": "It must be a pointer type."
        },
        "correct_answer": "B",
        "explanation": "The key type in a map must support the comparison operators '==' and '!='. This is necessary to ensure that keys can be compared for uniqueness, which is essential for the functionality of a map."
    },
    {
        "question": "How can the length of a map be determined?",
        "options": {
            "A": "By using the built-in function 'size()'",
            "B": "By using the built-in function 'len()'",
            "C": "By counting the elements manually",
            "D": "By accessing a property called 'length'"
        },
        "correct_answer": "B",
        "explanation": "The length of a map can be determined using the built-in function 'len()'. This function returns the number of elements currently stored in the map, which may change during execution as elements are added or removed."
    },
    {
        "question": "What happens if you try to add elements to a nil map?",
        "options": {
            "A": "The map will automatically initialize.",
            "B": "It will cause a runtime panic.",
            "C": "The elements will be added successfully.",
            "D": "The map will become empty."
        },
        "correct_answer": "B",
        "explanation": "Attempting to add elements to a nil map will cause a runtime panic. A nil map is equivalent to an empty map, but it does not allow for any elements to be added until it is initialized using the 'make()' function."
    },
    {
        "question": "What is the primary purpose of a channel in programming?",
        "options": {
            "A": "To store data persistently on disk",
            "B": "To facilitate communication between concurrently executing functions",
            "C": "To define the structure of data types",
            "D": "To manage memory allocation for variables"
        },
        "correct_answer": "B",
        "explanation": "The primary purpose of a channel is to facilitate communication between concurrently executing functions. Channels allow functions to send and receive values, enabling synchronization and data exchange in concurrent programming."
    },
    {
        "question": "What does the '<-' operator signify when used with channels?",
        "options": {
            "A": "It indicates the type of data being sent through the channel",
            "B": "It specifies the direction of communication for the channel",
            "C": "It denotes the capacity of the channel",
            "D": "It represents the initialization of the channel"
        },
        "correct_answer": "B",
        "explanation": "The '<-' operator specifies the direction of communication for the channel. It can indicate whether the channel is meant for sending values, receiving values, or both, thus defining its operational behavior."
    },
    {
        "question": "What happens when a channel is created with a capacity of zero?",
        "options": {
            "A": "The channel can store an unlimited number of values",
            "B": "The channel is unbuffered and communication requires both sender and receiver to be ready",
            "C": "The channel can only send values but not receive them",
            "D": "The channel is automatically closed after the first value is sent"
        },
        "correct_answer": "B",
        "explanation": "When a channel is created with a capacity of zero, it is unbuffered, meaning that communication will only succeed when both a sender and a receiver are ready. This ensures synchronization between the two operations."
    },
    {
        "question": "Which of the following statements is true about a nil channel?",
        "options": {
            "A": "A nil channel can be used for sending and receiving values",
            "B": "A nil channel is equivalent to an empty channel but cannot have elements added",
            "C": "A nil channel can be initialized with a specific capacity",
            "D": "A nil channel is always ready for communication"
        },
        "correct_answer": "B",
        "explanation": "A nil channel is equivalent to an empty channel in that it cannot have elements added to it. However, unlike an empty channel, a nil channel is never ready for communication, making it unusable for sending or receiving values."
    }
]